#!/usr/bin/perl

use Match;
use Location;

use Tree::Nary;

use CGI;

*UNSELECTED = \0;
*SELECTED_NAME = \1;
*SELECTED_MATCH = \2;
*CASCADE_SELECTED = \4;
*ANY_SELECTED = \7;
*FILLER = \8;

my @queryParameters = CGI::param();
my $string = CGI::param ('s');
my $selections = CGI::param ('sel');

my @selections = split (',', $selections);

if (not defined ($string)) {
    $string = "Test one two three";
}


main ();

sub buildSelectionLink {
    my ($selectionIndex) = shift;
   
    if (defined ($selections)) {
        $link = "?s=$string&sel=$selections,$selectionIndex";
    } else {
        $link = "?s=$string&sel=$selectionIndex";
    }

    return $link;
}

sub headerTable {
    my ($body, $location, $flags) = @_;

    $borderSize = 0;
    $bgColor = "#c0c0c0";
    $cellPadding = 0;
    $cellSpacing = 0;
    
    
    if (not defined ($flags)) {
        $flags = $UNSELECTED;
    }

    $leftFontColor = '#00000c';

    if (defined ($flags) and
       ($flags == $SELECTED_NAME or $flags == $SELECTED_MATCH or $flags == $CASCADE_SELECTED)) {

        $bgColor = 'black';
        $leftFontColor = 'white';
        $rightFontColor = '#0000cc';
    }


    my $output = "<table style='header'><tr>";
    
    foreach my $b (@$body) {
        $output .= "<td valign=top>$b</td>";
    }
    $output .= "</tr><tr><td valign=top colspan=" . scalar @$body . "> <table width='100%' bordercolor='$bgColor' bgcolor='$bgColor' cellspacing=$cellSpacing cellpadding=$cellPadding>";


    my $leftText, $rightText;
    my $leftLink, $rightLink;

    if (defined ($location)) {
        $leftText = $location->getName();
        $rightText = $location->getMatch();

        if ($rightText eq " ") {
            $rightText = "_";
        }

        $leftLink = buildSelectionLink ($location->getIndex ());
        $rightLink = buildSelectionLink ("-" . $location->getIndex ());
    } else {
        $leftText = "";
        $rightText = "";
        $leftLink = "";
        $rightLink = "";
    }


    

    if ($flags == $UNSELECTED) {
        $output .= "<tr> <td align=left ><a href='$leftLink' title='Match against '><font color='$leftFontColor' >$leftText</font></a> </td>";
        $output .= "<td align=right valign=bottom><a href='$rightLink' title='Match against '><font color='$rightFontColor' size=2>$rightText</font></a> </td> </tr> </table> </td> </tr> </table>";
    }
    elsif ($flags == $SELECTED_NAME) {
        $output .= "<tr> <td align=left>NAME</td>";
        $output .= "<td align=right valign=bottom>&nbsp;</td> </tr> </table> </td> </tr> </table>";
    } 
    elsif ($flags == $SELECTED_MATCH) {
        $output .= "<tr> <td align=left ></td>";
        $output .= "<td align=right valign=bottom><font size=2>MATCH</font></td> </tr> </table> </td> </tr> </table>";
    } 
    elsif ($flags == $CASCADE_SELECTED) {
        $output .= "<tr> <td align=left ></td>";
        $output .= "<td align=right valign=bottom>&nbsp;<td> </tr> </table> </td> </tr> </table>";
    }

    return $output;
}

sub fillerTable {
    my ($body, $flags) = @_;

    if (not defined ($flags)) {
        $flags = $UNSELECTED;
    }

    $color = '#c0c0c0';
    if ($flags & $ANY_SELECTED) {
        $color = 'black';
    }

    ## basically an inner table 
    my $output = "<table border=0 bgcolor='$color' cellpadding=0 cellspacing=0>";
    $output .= "<tr>";
    $output .= "<td valign=top>$body</td>";
    $output .= "</tr></table>";

    my @innerTables = ( innerTable ($body, "", $FILLER | $flags) );

    return headerTable (\@innerTables);
}

sub innerTable {
    my ($body, $color, $flags) = @_;

    if (not defined ($flags)) {
        $flags = $UNSELECTED;
    }

    my $borderSize = 1;
    my $color = "#c0c0c0";
    my $borderColor = "#c0c0c0";

    my $cellSpacing = 0;

    if ($flags & $SELECTED_NAME or 
        $flags & $SELECTED_MATCH or 
        $flags & $CASCADE_SELECTED) 
    {
        $color = 'black';
        $borderSize = 0;
        $borderColor = 'black';
        $cellSpacing = 1;
    }

    if ($flags & $FILLER) {
        $borderSize = 0;
        $cellSpacing = 1;
    }
    
    my $output = "";
    $output = "<table border=$borderSize cellpadding=$cellSpacing cellspacing=0>";
    $output .= "<tr>";
    $output .= "<td valign=top bgcolor='$color'>$body</td>";
    $output .= "</tr></table>";

    return $output;
}

sub charTable {
    my ($location, $flags) = @_;
    
    if (not defined ($flags)) {
        $flags = $UNSELECTED;
    }

    my $char = $location->getMatch();
    my $type = $location->getName();

    # Display spaces as underscores
    if ($char eq " ") {
        $char = "_";
    }

    my $output = "<table border=0> 
                    <tr>
                       <td valign=top align=center bgcolor='#fffff' cellpadding=2 cellspacing=2><font size=2 color='#000000'>$char</font></td>
                    </tr>";

    if ($flags & $SELECTED_MATCH or $flags & $SELECTED_NAME) {
        $output .= "<tr>
                        <td valign=top>
                            <table width='100%' border=0 cellspacing=0 cellpadding=0 bgcolor='black'>
                                <tr>
                                    <td align=left>&nbsp; </td>
                                    <td>&nbsp</td>
                                    <td align=right>&nbsp</td>
                                </tr>
                            </table>
                        </td>
                    </tr>";

    } 
    elsif ($flags & $CASCADE_SELECTED) {
        $output .= "<tr>
                        <td valign=top>
                            <table width='100%' border=0 cellspacing=0 cellpadding=0 bgcolor='black'>
                                <tr>
                                    <td align=left>&nbsp; </td>
                                    <td>&nbsp</td>
                                    <td align=right>&nbsp</td>
                                </tr>
                            </table>
                        </td>
                    </tr>";

    } 
    else {
        $leftLink = buildSelectionLink ($location->getIndex ());
        $rightLink = buildSelectionLink ("-" . $location->getIndex ());

        $output .= "<tr>
                        <td valign=top>
                            <table width='100%' border=0 cellspacing=0 cellpadding=0>
                                <tr>
                                    <td align=left><a href='$leftLink' title='Match against Any Single Character'><font color='#00000c'>$type</font></a></td>
                                    <td>&nbsp</td>
                                    <td align=right valign=bottom><a href='$rightLink' title='Match against t'><font color='#0000cc' size=2>$char</font></a></td>
                                </tr>
                            </table>
                        </td>
                    </tr>";
    }
    
    $output .= "</table>";

    return $output;
}

sub selectionFlags {
    my ($node) = shift;

    if (defined ($node->{data})) {
        my $searchRegex = "^" . $node->{data}->getIndex() . "\$";

        if (grep { /$searchRegex/ } @selections) {
            return $SELECTED_NAME;
        } else {
            $searchRegex = "^-" . $node->{data}->getIndex() . "\$";

            if (grep { /$searchRegex/ } @selections) {
                return $SELECTED_MATCH;
            }
        }
    }

    return $UNSELECTED;
}

sub traverseTree {
    my ($tree, $maxHeight, $currentHeight, $flags) = @_;
   
    my @subLevels = ();
    
   
    # Determine if the cell is selected
    if (not defined ($flags)) {
        $flags = selectionFlags ($tree);
    }

    # Traverse all the sub children
    $node = $tree->{children};
    while (defined ($node)) {
        my $next = Tree::Nary->new ();
        $next = $node->{next};

        my $data = $node->{data};

        my $childFlags = $flags;
        if ($flags & $SELECTED_NAME or 
            $flags & $SELECTED_MATCH) 
        {
            $childFlags = $CASCADE_SELECTED;
        }

        # Determine if the next cell is selected... what a pain in the ass
        if ($childFlags != $CASCADE_SELECTED) {
            $childFlags = selectionFlags ($node);
        }

        if (Tree::Nary->is_leaf ($node)) {
            # Character table
            my $charTable = charTable ($data, $childFlags);
            if ($currentHeight < $maxHeight) {

                # Filler table needed to make the characters line up correctly
                for (my $i = $currentHeight; $i < $maxHeight; $i++) {
                    $charTable = fillerTable ($charTable, $childFlags); 
                }
            }

            $charTable = innerTable ($charTable, "#c0c0c0", $childFlags);

            push (@subLevels, $charTable);
        } else {
            # Recursive call needed

            # Determine if the next cell is selected... what a pain in the ass
            if ($childFlags != $CASCADE_SELECTED) {
                $childFlags = selectionFlags ($node);
            }

            push (@subLevels, innerTable (traverseTree ($node, $maxHeight, $currentHeight + 1, $childFlags), "#c0c0c0", $childFlags));

        }
        
        $node = $next;
    }
    
                                                                                   
    if (defined ($tree->{data})) {
        $output = headerTable (\@subLevels, $tree->{data}, $flags);
    } else {
        my @innerTables = (innerTable (headerTable (\@subLevels), "#c0c0c0", $flags));
        $output = headerTable (\@innerTables);
    }

    return $output;
}


# Convert hashed locations to an Nary tree
sub locationsToTree (\@) {
    my ($matchedLocations) = @_;

    my $tree = Tree::Nary->new ();

    my $parent = $tree;

    @$matchedLocations = sort Match::locationSortComparatorReversed @$matchedLocations;

    foreach my $location (@$matchedLocations) {
        # Create a new node for the item
        my $node = Tree::Nary->new ($location);


        if (defined ($parent->{data}) and
            defined ($parent->{data}->getStart())) {

            if ($parent->{data}->getStart () < $location->getStart () and 
                $parent->{data}->getEnd () < $location->getEnd ()) {

                while (defined ($parent->{data}) and
                       $parent->{data}->getStart () < $location->getStart () and 
                       $parent->{data}->getEnd () < $location->getEnd () and
                       $parent->{parent} != $parent) 
                {
                    $parent = $parent->{parent};
                }
                $node->append ($parent, $node);

                $parent = $node;
            } else {
                $node->append ($parent, $node);
                $parent = $node;
            }
        

        } else {
            $node->append ($parent, $node);
            $parent = $node;
        }
            
    }

    return $tree;
}

sub main {
    print "Content-type: text/html\n\n";

    print "<html><head>";

    print <<END;

    <style type="text/css">
    
        table.header {
            border-width: 0px;
            border-color: #FFFFFF;
        }

        td {
            border-width: 0px;
            border-style: solid;
            border-color: #FFFFFF;
        }

    </style>


END
    
    my $testCase = $string;
    my @mappingsList = Match::getGeneralMappings();
    my @matchedLocations = Match::findMatches ($testCase, @mappingsList);
    
    print "<pre>";
    
    #Match::printLocations (@matchedLocations);

    $testTree = locationsToTree (@matchedLocations);
    my $treeHeight = $testTree->max_height ($testTree);
    print "Tree height: $treeHeight\n";
    my $tableBody = traverseTree ($testTree, $treeHeight, 1);
    print "</pre>";
   
    print $tableBody;

    print "<br/>";
    print "<br/>";
    print "<br/>";


    my @userSelections = split (',', $selections);
    print "<pre>";
    Match::printLocations (@matchedLocations);
    my @matchedLocations = Match::findMatches ($testCase, @mappingsList);
    my $regEx = Match::buildRegex($testCase, @matchedLocations, @userSelections);
    print "Regex: $regEx\n";
    print "</pre>";

    print "</body></html>";
}
